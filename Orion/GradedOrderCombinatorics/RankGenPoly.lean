/-
  Orion/GradedOrderCombinatorics/RankGenPoly.lean

  Graded Order Combinatorics — Layer 2: Rank Generating Polynomials
  Generated by Library Weaver.
-/

import Mathlib

namespace Orion.GradedOrderCombinatorics

-- Definitions and proofs below are generated by the Proof Oracle.

noncomputable def rankGenPoly (α : Type*) [Fintype α] [DecidableEq α] [Preorder α] [GradeOrder ℕ α] : Polynomial ℕ :=
  ∑ k ∈ (Finset.univ : Finset α).image (grade ℕ), (Finset.univ.filter (fun x : α => grade ℕ x = k)).card • (Polynomial.X ^ k)

theorem rankGenPoly_eval_one (α : Type*) [Fintype α] [DecidableEq α] [Preorder α] [GradeOrder ℕ α] :
    Polynomial.eval 1 (rankGenPoly α) = Fintype.card α := by
  unfold rankGenPoly
  rw [Polynomial.eval_finset_sum]
  simp only [Polynomial.eval_smul, Polynomial.eval_pow, Polynomial.eval_X, one_pow, smul_eq_mul, mul_one]
  exact (Finset.card_eq_sum_card_image (grade ℕ) (Finset.univ : Finset α)).symm.trans Finset.card_univ

theorem rankGenPoly_coeff (α : Type*) [Fintype α] [DecidableEq α] [Preorder α]
    [GradeOrder ℕ α] (k : ℕ) :
    Polynomial.coeff (rankGenPoly α) k =
      ((Finset.univ : Finset α).filter (fun x : α => grade ℕ x = k)).card := by
  unfold rankGenPoly
  rw [Polynomial.finset_sum_coeff]
  simp_rw [Polynomial.coeff_smul, Polynomial.coeff_X_pow]
  simp only [smul_eq_mul, mul_ite, mul_one, mul_zero]
  rw [Finset.sum_ite_eq]
  split_ifs with h
  · rfl
  · symm
    rw [Finset.card_eq_zero]
    rw [Finset.filter_eq_empty_iff]
    rw [Finset.mem_image] at h
    push_neg at h
    intro x _
    exact h x (Finset.mem_univ x)

theorem rankGenPoly_natDegree (α : Type*) [Fintype α] [DecidableEq α] [Preorder α]
    [GradeOrder ℕ α] [Nonempty α] :
    (rankGenPoly α).natDegree =
      ((Finset.univ : Finset α).image (grade ℕ)).max'
        (Finset.image_nonempty.mpr Finset.univ_nonempty) := by
  set S := (Finset.univ : Finset α).image (grade ℕ)
  set m := S.max' (Finset.image_nonempty.mpr Finset.univ_nonempty)
  apply le_antisymm
  · -- Upper bound: natDegree ≤ m
    rw [Polynomial.natDegree_le_iff_coeff_eq_zero]
    intro n hn
    rw [rankGenPoly_coeff]
    rw [Finset.card_eq_zero, Finset.filter_eq_empty_iff]
    intro x _
    have hx : grade ℕ x ∈ S := Finset.mem_image_of_mem (grade ℕ) (Finset.mem_univ x)
    have hle : grade ℕ x ≤ m := Finset.le_max' S (grade ℕ x) hx
    omega
  · -- Lower bound: m ≤ natDegree
    apply Polynomial.le_natDegree_of_ne_zero
    rw [rankGenPoly_coeff]
    have hm : m ∈ S := Finset.max'_mem S _
    rw [Finset.mem_image] at hm
    obtain ⟨x, _, hx⟩ := hm
    have : (Finset.univ.filter (fun y : α => grade ℕ y = m)).Nonempty :=
      ⟨x, Finset.mem_filter.mpr ⟨Finset.mem_univ x, hx⟩⟩
    exact Finset.card_pos.mpr this |>.ne'

theorem rankGenPoly_eval_zero (α : Type*) [Fintype α] [DecidableEq α] [Preorder α] [GradeOrder ℕ α] :
    Polynomial.eval 0 (rankGenPoly α) =
      ((Finset.univ : Finset α).filter (fun x : α => grade ℕ x = 0)).card := by
  rw [← Polynomial.coeff_zero_eq_eval_zero]
  exact rankGenPoly_coeff α 0

theorem rankGenPoly_coeff_eq_zero (α : Type*) [Fintype α] [DecidableEq α] [Preorder α]
    [GradeOrder ℕ α] (k : ℕ) (h : ∀ x : α, grade ℕ x ≠ k) :
    Polynomial.coeff (rankGenPoly α) k = 0 := by
  rw [rankGenPoly_coeff]
  rw [Finset.card_eq_zero, Finset.filter_eq_empty_iff]
  intro x _
  exact h x

end Orion.GradedOrderCombinatorics
