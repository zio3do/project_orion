/-
  Orion/GradedOrderCombinatorics/SaturatedChains.lean

  Graded Order Combinatorics â€” Layer 3: Saturated Chains and Maximal Chains
  Generated by Library Weaver.
-/

import Mathlib

namespace Orion.GradedOrderCombinatorics

-- Definitions and proofs below are generated by the Proof Oracle.

theorem saturatedChain_length [Preorder Î±] [GradeMinOrder â„• Î±] (l : List Î±)
    (hl : l.IsChain (Â· â‹– Â·)) (hne : l â‰  []) :
    grade â„• (l.getLast hne) = grade â„• (l.head hne) + (l.length - 1) := by
  induction l with
  | nil => exact absurd rfl hne
  | cons a t ih =>
    cases t with
    | nil => simp
    | cons b rest =>
      have hne' : b :: rest â‰  [] := List.cons_ne_nil _ _
      have htail : (b :: rest).IsChain (Â· â‹– Â·) := List.IsChain.tail hl
      have hrel : a â‹– b := List.IsChain.rel_head hl
      have ih' := ih htail hne'
      have hgrad : grade â„• a + 1 = grade â„• b :=
        Order.covBy_iff_add_one_eq.mp (hrel.grade (ð•† := â„•))
      rw [show (a :: b :: rest).getLast hne = (b :: rest).getLast hne' from
        List.getLast_cons hne']
      simp only [List.head_cons, List.length_cons] at ih' âŠ¢
      omega

theorem saturatedChain_exists [PartialOrder Î±] [GradeMinOrder â„• Î±] (a b : Î±) (hab : a â‰¤ b) :
    âˆƒ (l : List Î±) (hne : l â‰  []),
      l.IsChain (Â· â‹– Â·) âˆ§ l.head hne = a âˆ§ l.getLast hne = b := by
  -- WellFoundedLT Î± and IsStronglyAtomic Î± are automatic from GradeMinOrder â„• Î±
  -- Strong induction on the grade gap
  suffices h : âˆ€ n, âˆ€ a b : Î±, a â‰¤ b â†’ grade â„• b - grade â„• a = n â†’
      âˆƒ (l : List Î±) (hne : l â‰  []),
        l.IsChain (Â· â‹– Â·) âˆ§ l.head hne = a âˆ§ l.getLast hne = b from
    h _ a b hab rfl
  intro n
  induction n using Nat.strongRecOn with
  | ind n ih =>
    intro a b hab hgap
    obtain rfl | hlt := eq_or_lt_of_le hab
    Â· -- Base case: a = b, chain is [a]
      exact âŸ¨[a], List.cons_ne_nil _ _, List.isChain_singleton _, rfl, rflâŸ©
    Â· -- Inductive case: a < b, find c with a â‹– c â‰¤ b
      obtain âŸ¨c, hac, hcbâŸ© := exists_covBy_le_of_lt hlt
      have hgac : grade â„• c = grade â„• a + 1 :=
        (Order.covBy_iff_add_one_eq.mp (hac.grade (ð•† := â„•))).symm
      have hga_lt_gb : grade â„• a < grade â„• b := grade_strictMono hlt
      have hgap' : grade â„• b - grade â„• c < n := by omega
      obtain âŸ¨l, hne, hchain, hhead, hlastâŸ© := ih _ hgap' c b hcb rfl
      refine âŸ¨a :: l, List.cons_ne_nil _ _, ?_, rfl, ?_âŸ©
      Â· -- Chain': a â‹– l.head âˆ§ l is a chain
        subst hhead
        exact List.IsChain.cons_of_ne_nil hne hchain hac
      Â· -- getLast (a :: l) = b
        rw [List.getLast_cons hne]
        exact hlast

theorem saturatedChain_length_const [Preorder Î±] [GradeMinOrder â„• Î±] (câ‚ câ‚‚ : List Î±)
    (hcâ‚ : câ‚.IsChain (Â· â‹– Â·)) (hcâ‚‚ : câ‚‚.IsChain (Â· â‹– Â·))
    (hneâ‚ : câ‚ â‰  []) (hneâ‚‚ : câ‚‚ â‰  [])
    (hhead : câ‚.head hneâ‚ = câ‚‚.head hneâ‚‚) (hlast : câ‚.getLast hneâ‚ = câ‚‚.getLast hneâ‚‚) :
    câ‚.length = câ‚‚.length := by
  have hâ‚ := saturatedChain_length câ‚ hcâ‚ hneâ‚
  have hâ‚‚ := saturatedChain_length câ‚‚ hcâ‚‚ hneâ‚‚
  rw [hhead, hlast] at hâ‚
  have hlenâ‚ : 0 < câ‚.length := by rcases câ‚ with _ | _; exact absurd rfl hneâ‚; exact Nat.succ_pos _
  have hlenâ‚‚ : 0 < câ‚‚.length := by rcases câ‚‚ with _ | _; exact absurd rfl hneâ‚‚; exact Nat.succ_pos _
  omega

theorem grade_le_of_chain [Preorder Î±] [GradeMinOrder â„• Î±] (l : List Î±)
    (hl : l.IsChain (Â· â‹– Â·)) (hne : l â‰  []) :
    grade â„• (l.head hne) â‰¤ grade â„• (l.getLast hne) := by
  have h := saturatedChain_length l hl hne
  omega

theorem saturatedChain_length_grade_diff [Preorder Î±] [GradeMinOrder â„• Î±] (l : List Î±)
    (hl : l.IsChain (Â· â‹– Â·)) (hne : l â‰  []) :
    l.length = grade â„• (l.getLast hne) - grade â„• (l.head hne) + 1 := by
  have h := saturatedChain_length l hl hne
  have hle := grade_le_of_chain l hl hne
  have hlen : 0 < l.length := by rcases l with _ | _; exact absurd rfl hne; exact Nat.succ_pos _
  omega

theorem saturatedChain_grade_strictMono [Preorder Î±] [GradeMinOrder â„• Î±] (l : List Î±)
    (hl : l.IsChain (Â· â‹– Â·)) : l.Pairwise (fun a b => grade â„• a < grade â„• b) := by
  induction l with
  | nil => exact List.Pairwise.nil
  | cons a t ih =>
    apply List.Pairwise.cons
    Â· intro b hb
      cases t with
      | nil => simp at hb
      | cons c rest =>
        have hac : a â‹– c := List.IsChain.rel_head hl
        have hgrade_ac : grade â„• a < grade â„• c := grade_strictMono hac.lt
        rcases List.mem_cons.mp hb with rfl | hb_rest
        Â· exact hgrade_ac
        Â· have hpair_tail := (List.pairwise_cons.mp (ih (List.IsChain.tail hl))).1
          exact lt_trans hgrade_ac (hpair_tail b hb_rest)
    Â· exact ih (List.IsChain.tail hl)

-- Using l.IsChain (Â· â‹– Â·) instead of the suggested l.Chain' (Â· â‹– Â·) for consistency
-- with the rest of this file (Chain' is deprecated; IsChain is the current API).
theorem saturatedChain_nodup [Preorder Î±] [GradeMinOrder â„• Î±] (l : List Î±)
    (hl : l.IsChain (Â· â‹– Â·)) : l.Nodup := by
  rw [List.nodup_iff_pairwise_ne]
  apply (saturatedChain_grade_strictMono l hl).imp
  intro a b h heq
  subst heq
  exact lt_irrefl _ h

end Orion.GradedOrderCombinatorics
