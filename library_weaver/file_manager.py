"""
File Manager — manages Lean file lifecycle: seeding, snapshotting, restoring.

Handles three responsibilities:
  1. Seeding: creates target .lean files with import headers and namespace
     blocks if they don't already exist.
  2. Snapshotting: saves the current state of a target file before each
     Oracle invocation, so it can be restored on failure.
  3. Restoring: returns a target file to its pre-attempt state when the
     Oracle fails or corrupts the file.

Snapshots are simple file copies stored in the run directory. Each file
is <1KB of Lean code, so copies are trivial.
"""

from __future__ import annotations

import shutil
from pathlib import Path

from library_weaver.models import ExistingEntry


class FileManager:
    """Manages Lean file seeding, snapshotting, and restoring.

    All target_file paths are relative to project_root (e.g.
    "Orion/GradedOrderCombinatorics/LevelSets.lean").
    """

    def __init__(self, project_root: Path, run_dir: Path) -> None:
        self._project_root = project_root
        self._snapshot_dir = run_dir / "file_snapshots"
        self._snapshot_dir.mkdir(parents=True, exist_ok=True)
        self._snapshot_counter: int = 0

    def seed_file(
        self,
        target_file: str,
        namespace: str,
        theme: str,
        layer: str,
    ) -> bool:
        """Create a target file with import header and namespace block.

        Does nothing if the file already exists.

        Returns:
            True if the file was created, False if it already existed.
        """
        full_path = self._project_root / target_file
        if full_path.exists():
            return False

        full_path.parent.mkdir(parents=True, exist_ok=True)

        header = (
            f"/-\n"
            f"  {target_file}\n"
            f"\n"
            f"  {theme} — {layer}\n"
            f"  Generated by Library Weaver.\n"
            f"-/\n"
            f"\n"
            f"import Mathlib\n"
            f"\n"
            f"namespace {namespace}\n"
            f"\n"
            f"-- Definitions and proofs below are generated by the Proof Oracle.\n"
            f"\n"
            f"end {namespace}\n"
        )

        full_path.write_text(header, encoding="utf-8")
        return True

    def write_definition(self, existing: ExistingEntry) -> bool:
        """Write an exists_in_mathlib definition into a seeded file.

        Inserts the definition before the closing ``end <namespace>`` line.
        Does nothing if the definition text is already present in the file.

        Returns:
            True if the definition was written, False if already present.
        """
        if not existing.target_file or not existing.suggested_signature:
            return False

        full_path = self._project_root / existing.target_file
        if not full_path.exists():
            return False

        content = full_path.read_text(encoding="utf-8")

        # Check if the definition is already in the file
        if existing.name in content:
            return False

        # Insert before the closing `end <namespace>` line
        end_marker = f"end {existing.target_namespace}"
        if end_marker not in content:
            return False

        definition_block = f"{existing.suggested_signature}\n\n"
        content = content.replace(end_marker, definition_block + end_marker)
        full_path.write_text(content, encoding="utf-8")
        return True

    def snapshot(self, target_file: str) -> str:
        """Save the current state of target_file. Returns a snapshot ID.

        The snapshot is a simple file copy. The snapshot ID is used to
        restore the file if the Oracle fails.
        """
        full_path = self._project_root / target_file
        self._snapshot_counter += 1
        snapshot_id = f"snap_{self._snapshot_counter:04d}"

        # Sanitise filename: replace / with _
        safe_name = target_file.replace("/", "_")
        snapshot_path = self._snapshot_dir / f"{safe_name}_{snapshot_id}.lean"

        shutil.copy2(str(full_path), str(snapshot_path))
        return snapshot_id

    def restore(self, target_file: str, snapshot_id: str) -> None:
        """Restore target_file from a snapshot."""
        full_path = self._project_root / target_file
        safe_name = target_file.replace("/", "_")
        snapshot_path = self._snapshot_dir / f"{safe_name}_{snapshot_id}.lean"

        if not snapshot_path.exists():
            raise FileNotFoundError(f"Snapshot not found: {snapshot_path}")

        shutil.copy2(str(snapshot_path), str(full_path))

    def file_exists(self, target_file: str) -> bool:
        """Check if a target file exists."""
        return (self._project_root / target_file).exists()

    def read_file(self, target_file: str) -> str:
        """Read the contents of a target file."""
        return (self._project_root / target_file).read_text(encoding="utf-8")
